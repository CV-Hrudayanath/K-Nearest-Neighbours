import csv, random, math
#pandas
from decimal import Decimal
import matplotlib.pyplot as plt

filename = "iris.data" #dataset file name
k = 1 #no of nearest neighbors to consider
iterations = 10
"""Classes in each Dataset"""
types = ["Iris-setosa", "Iris-virginica", "Iris-versicolor"] #Iris Data Set
#types = ["1", "2"] #Haberman's Survival Data Set
#types = ["0", "1"] #Blood Transfusion Service Center Data Set
num = len(types)

def makeDataset():
	dataset = []
	with open(filename, 'rb') as f:
		reader = csv.reader(f)
		for row in reader:
			for i in range(0,len(row)-1):
				row[i] = float(row[i])
			dataset.append(row)
	return dataset

def shuffleDataset(dataset):
	datasetcopy = dataset[:]
	random.shuffle(datasetcopy)
	return datasetcopy
	

def actualClasses(testing):
	actual = []
	for i in testing:
		actual.append(i[-1])
	return actual

def getKey(item):
    return item[1]

def getDistance(data1, data2):
	squareDiff = 0
	for i in range(0,len(data1)):
		squareDiff += pow((data1[i] - data2[i]),2)
	distance = math.sqrt(squareDiff)
	return distance

def getNeighbors(test, training):
	distances = []
	for i in range(len(training)):
		distance = getDistance(test, training[i][:-1])
		distances.append([i, distance])
	distances = sorted(distances, key=getKey)
	neighbors = []
	for i in distances[:k]:
		neighbors.append(i[0])
	return neighbors

def mostCommon(lst):
    return max(set(lst), key=lst.count)

def actualClasses(testing):
	actual = []
	for i in testing:
		actual.append(i[-1])
	return actual

def predictClasses(testing, training):
	predicted = []
	for test in testing:
		neighbors = getNeighbors(test[:-1], training)
		classes = []
		for i in neighbors:
			classes.append(training[i][-1])
		predicted.append(mostCommon(classes))
	return predicted

def matchType(word):
	for i in range(len(types)):
		if types[i] == word:
			return i

def findConfusion(actual, predicted):
	confusion = [[0]*num for i in range(num)]
	length = len(actual)
	count = 0

	for i in range(len(actual)):
		count += 1
		confusion[matchType(actual[i])][matchType(predicted[i])] += 1

	for i in range(num):
		for j in range(num):
			confusion[i][j] /= float(length)
			confusion[i][j] = round(Decimal(confusion[i][j]*100),3)
	return confusion
		

def findAccuracy(confusion):
	accuracy = 0.0
	for i in range(len(confusion)):
		accuracy += confusion[i][i]
	return accuracy

def addMatrix(X, Y):
	result = [[0]*num for i in range(num)]
	for i in range(len(X)):
		for j in range(len(X[0])):
			result[i][j] = round(Decimal(X[i][j] + Y[i][j]),3)
	return result

def divideMatrix(X, k):
	result = [[0]*num for i in range(num)]
	for i in range(len(X)):
		for j in range(len(X[0])):
			result[i][j] = round(Decimal(X[i][j]/k),3)
	return result

def findMatchSet(class1,class2):
	if set([class1,class2]) == set([types[0],types[1]]):
		return 0
	elif set([class1,class2]) == set([types[1],types[2]]):
		return 1
	elif set([class1,class2]) == set([types[2],types[0]]):
		return 2

def decisonBoundaries(training, testing, predicted):
	actual = actualClasses(training)
	dataset = training + testing 
	classification = actual + predicted
	new = []
	classes = []
	for i in range(len(types)):
		classes.append([[],[]])
	for i in range(len(dataset)):
		new.append([dataset[i][1]] + [dataset[i][3]] + [classification[i]])
		print classification[i]
		j = matchType(classification[i])
		classes[j][0].append(dataset[i][3]) #to be able to color each class
		classes[j][1].append(dataset[i][1])
	new.sort(key=lambda item: (item[0], item[1]))
	print new
	pointx = []
	pointy = []
	for i in range(len(types)):
		pointx.append([])
		pointy.append([])

	one = new[0][:]
	for i in new[1:]:
		two = i[:]
		class1 = one[2][:]
		class2 = two[2][:]
		if class1 == class2 or one[0] != two[0]:
			one = two[:]
			continue
		print one, two
		j = findMatchSet(class1,class2) #to be able to draw a line separating each pair of classes

		pointy[j].append((one[0]+two[0])/2.0) 
		pointx[j].append((one[1]+two[1])/2.0)
		one = two[:]

	plt.xlabel('Petal width')
	plt.ylabel('Sepal width')

	plt.plot(pointx[0],pointy[0],marker='o',color='r',linestyle='-')
	plt.plot(pointx[1],pointy[1],marker='o',color='r',linestyle='-')
	plt.plot(pointx[2],pointy[2],marker='o',color='r',linestyle='-')
	xset = [pointx[0][-1]]+[pointx[1][-1]]+[pointx[2][-1]]
	yset = [pointy[0][-1]]+[pointy[1][-1]]+[pointy[2][-1]]
	plt.plot(xset,yset,marker='o',color='r',linestyle='-')

	plt.scatter(classes[0][0],classes[0][1],40,'b','^')
	plt.scatter(classes[1][0],classes[1][1],40,"#FFFFFF",'s')
	plt.scatter(classes[2][0],classes[2][1],50,'g','^')
	plt.show()

def randomSubsampling(dataset):
	sets = shuffleDataset(dataset) #randomizes sample order
	training = sets[:len(dataset)/2]
	testing = sets[len(dataset)/2:]
	actual = actualClasses(testing)
	predicted = predictClasses(testing, training)
	confusion = findConfusion(actual, predicted)
	accuracy = findAccuracy(confusion)
	decisonBoundaries(training, testing, predicted)
	return [accuracy, confusion]




def kfoldCrossValidation(dataset):
	sets = shuffleDataset(dataset) #randomizes sample order
	length = len(dataset)
	foldsize = length/5
	sumconfusion = [[0]*num for i in range(num)]
	accuracy = []
	for i in range(5):
		testing = sets[foldsize*i:foldsize*(i+1)]
		training = sets[:foldsize*i] + sets[foldsize*(i+1):]
		actual = actualClasses(testing) 
		predicted = predictClasses(testing, training)
		confusion = findConfusion(actual, predicted)
		sumconfusion = addMatrix(sumconfusion, confusion)
		accuracy.append(findAccuracy(confusion))
	sumaccuracy = sum(accuracy)
	printAccuracies(accuracy)
	return [round(Decimal(sumaccuracy/5.0),3), divideMatrix(sumconfusion, 5.0)]


def calculateVariance(mean, values):
	squareDiff = 0
	for i in range(0,len(values)):
		squareDiff += pow((mean - values[i]),2)
	squareDiff = squareDiff/len(values)
	return round(Decimal(squareDiff),5)


def printAccuracies(accuracies):
	print "\n  Accuracy"
	print " ----------"
	mean = round(Decimal(sum(accuracies)/len(accuracies)),3)
	variance = calculateVariance(mean, accuracies)
	for i in range(len(accuracies)):
		print  "  " + repr(round(Decimal(accuracies[i]),3)),
		if i == len(accuracies)/2-1:
			print "          mean     : " + repr(mean) 
		elif i == len(accuracies)/2:
			print "          variance : " + repr(variance)
		else:
			print ""


def start():
	dataset = makeDataset() # reads csv file and stores dataset
	accuracies = []
	sumconfusion = [[0]*num for i in range(num)]
	for i in range(iterations):
		result = randomSubsampling(dataset)
		#result = kfoldCrossValidation(dataset)
		confusion = result[1]
		sumconfusion = addMatrix(sumconfusion, confusion)
		accuracies.append(result[0])
	printAccuracies(accuracies)
	#print pandas.DataFrame(divideMatrix(sumconfusion,10.0), types, types)
	


start()
